/* Generated by gentables.py, do not edit. */

package io.github.paiv.uklatn;

import static java.util.Map.entry;

import java.text.Normalizer;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.regex.MatchResult;
import java.util.regex.Pattern;

/**
* Ukrainian Cyrillic transliteration to and from Latin script.
*/
public final class UkrainianLatin {

    /**
    * Transliteration system
    */
    public static final class UKLatnTable {

        /** DSTU 9112:2021 System A */
        public static final int DSTU_9112_A = 1;

        /** DSTU 9112:2021 System B */
        public static final int DSTU_9112_B = 2;

        /** KMU 55:2010, not reversible */
        public static final int KMU_55 = 3;
    }

    /**
    * Transliterates a string of Ukrainian Cyrillic to Latin script,
    * using {@link UKLatnTable#DSTU_9112_A}.
    *
    * @param text the text to transliterate
    * @return transliterated text
    */
    public String encode(String text) {
        return encode(text, UKLatnTable.DSTU_9112_A);
    }

    /**
    * Transliterates a string of Ukrainian Cyrillic to Latin script.
    *
    * @param text the text to transliterate
    * @param table transliteration system, see {@link UKLatnTable}
    * @return transliterated text
    */
    public String encode(String text, int table) {
        _UKLatnTransformer tr = null;
        if (table >= 0 && table < _UklatnTables.length) {
            _UKLatnTransformer[] codecs = _UklatnTables[table];
            if (codecs != null) { tr = codecs[0]; }
        }
        if (tr == null) { throw new IllegalArgumentException("invalid table " + String.valueOf(table)); }
        return tr.transform(text);
    }

    /**
    * Re-transliterates a string of Ukrainian Latin to Cyrillic script,
    * using {@link UKLatnTable#DSTU_9112_A}.
    *
    * @param text the text to transliterate
    * @return transliterated text
    */
    public String decode(String text) {
        return decode(text, UKLatnTable.DSTU_9112_A);
    }

    /**
    * Re-transliterates a string of Ukrainian Latin to Cyrillic script.
    *
    * @param text the text to transliterate
    * @param table transliteration system, see {@link UKLatnTable}
    * @return transliterated text
    */
    public String decode(String text, int table) {
        _UKLatnTransformer tr = null;
        if (table >= 0 && table < _UklatnTables.length) {
            _UKLatnTransformer[] codecs = _UklatnTables[table];
            if (codecs != null) { tr = codecs[1]; }
        }
        if (tr == null) { throw new IllegalArgumentException("invalid table " + String.valueOf(table)); }
        return tr.transform(text);
    }

    private static interface _UKLatnTransformer {
        String transform(String text);
    }

    private static class _Uklatn_uk_uk_Latn_DSTU_9112_A implements _UKLatnTransformer {
        private Pattern _rx1;
        private Function<MatchResult,String> _tr1;

        _Uklatn_uk_uk_Latn_DSTU_9112_A() {
            this._rx1 = Pattern.compile("\\b([Ьь])|([Ьь](?=[АаЕеУу])|[ЄЮЯ](?=\\u0301?[а-щьюяєіїґ’])|(?<=[Б-ДЖЗК-НП-ТФ-Щб-джзк-нп-тф-щҐґ])[Йй])|([ЁЄІЇЎА-яёєіїўҐґ’])", Pattern.UNICODE_CHARACTER_CLASS);
            List<Map<String,String>> _maps1 = List.of(
                Map.ofEntries(
                    entry("Ь","Ĵ"),entry("ь","ĵ")
                ),
                Map.ofEntries(
                    entry("Ь","J'"),entry("ь","j'"),entry("Є","Je"),entry("Ю","Ju"),entry("Я","Ja"),entry("Й","'J"),entry("й","'j")
                ),
                Map.ofEntries(
                    entry("А","A"),entry("а","a"),entry("Б","B"),entry("б","b"),entry("В","V"),entry("в","v"),entry("Г","Ğ"),entry("г","ğ"),entry("Ґ","G"),entry("ґ","g"),entry("Д","D"),entry("д","d"),entry("Е","E"),entry("е","e"),entry("Є","JE"),entry("є","je"),entry("Ж","Ž"),entry("ж","ž"),entry("З","Z"),entry("з","z"),entry("И","Y"),entry("и","y"),entry("І","I"),entry("і","i"),entry("Ї","Ï"),entry("ї","ï"),entry("К","K"),entry("к","k"),entry("Л","L"),entry("л","l"),entry("М","M"),entry("м","m"),entry("Н","N"),entry("н","n"),entry("О","O"),entry("о","o"),entry("П","P"),entry("п","p"),entry("Р","R"),entry("р","r"),entry("С","S"),entry("с","s"),entry("Т","T"),entry("т","t"),entry("У","U"),entry("у","u"),entry("Ф","F"),entry("ф","f"),entry("Х","X"),entry("х","x"),entry("Ц","C"),entry("ц","c"),entry("Ч","Č"),entry("ч","č"),entry("Ш","Š"),entry("ш","š"),entry("Щ","Ŝ"),entry("щ","ŝ"),entry("Ю","JU"),entry("ю","ju"),entry("Я","JA"),entry("я","ja"),entry("Ь","J"),entry("ь","j"),entry("Й","J"),entry("й","j"),entry("’","'"),entry("Ё","Ö"),entry("ё","ö"),entry("Ў","Ŭ"),entry("ў","ŭ"),entry("Ъ","Ǒ"),entry("ъ","ǒ"),entry("Ы","Ȳ"),entry("ы","ȳ"),entry("Э","Ē"),entry("э","ē")
                )
            );
            this._tr1 = (match) -> {
                for (int i = match.groupCount(); i > 0; i -= 1) {
                    String value = match.group(i);
                    if (value != null) {
                        return _maps1.get(i-1).getOrDefault(value, value);
                    }
                }
                return match.group();
            };
        }

        @Override
        public String transform(String text) {
            text = Normalizer.normalize(text, Normalizer.Form.NFC);
            text = this._rx1.matcher(text).replaceAll(this._tr1);
            text = Normalizer.normalize(text, Normalizer.Form.NFC);
            return text;
        }
    }

    private static class _Uklatn_uk_uk_Latn_DSTU_9112_B implements _UKLatnTransformer {
        private Pattern _rx1;
        private Function<MatchResult,String> _tr1;

        _Uklatn_uk_uk_Latn_DSTU_9112_B() {
            this._rx1 = Pattern.compile("([Ьь](?=[АаЕеІіУу])|(?<=[Б-ДЖЗК-НП-ТФ-Щб-джзк-нп-тф-щҐґ])[Йй])|([ГЄЖЇХЩШЧЮЯЁЎЪЫЭ](?=\\u0301?[а-яёєіїўґ’])|\\b[Ьь])|([ЁЄІЇЎА-яёєіїўҐґ’])", Pattern.UNICODE_CHARACTER_CLASS);
            List<Map<String,String>> _maps1 = List.of(
                Map.ofEntries(
                    entry("Ь","J'"),entry("ь","j'"),entry("Й","'J"),entry("й","'j")
                ),
                Map.ofEntries(
                    entry("Г","Gh"),entry("Є","Je"),entry("Ж","Zh"),entry("Ї","Ji"),entry("Х","Kh"),entry("Щ","Shch"),entry("Ш","Sh"),entry("Ч","Ch"),entry("Ю","Ju"),entry("Я","Ja"),entry("Ё","Jow"),entry("Ў","Uh"),entry("Ъ","Oh"),entry("Ы","Yw"),entry("Э","Ehw"),entry("Ь","Hj"),entry("ь","hj")
                ),
                Map.ofEntries(
                    entry("А","A"),entry("а","a"),entry("Б","B"),entry("б","b"),entry("В","V"),entry("в","v"),entry("Г","GH"),entry("г","gh"),entry("Ґ","G"),entry("ґ","g"),entry("Д","D"),entry("д","d"),entry("Е","E"),entry("е","e"),entry("Є","JE"),entry("є","je"),entry("Ж","ZH"),entry("ж","zh"),entry("З","Z"),entry("з","z"),entry("И","Y"),entry("и","y"),entry("І","I"),entry("і","i"),entry("Ї","JI"),entry("ї","ji"),entry("Х","KH"),entry("х","kh"),entry("К","K"),entry("к","k"),entry("Л","L"),entry("л","l"),entry("М","M"),entry("м","m"),entry("Н","N"),entry("н","n"),entry("О","O"),entry("о","o"),entry("П","P"),entry("п","p"),entry("Р","R"),entry("р","r"),entry("Щ","SHCH"),entry("щ","shch"),entry("Ш","SH"),entry("ш","sh"),entry("С","S"),entry("с","s"),entry("Т","T"),entry("т","t"),entry("У","U"),entry("у","u"),entry("Ф","F"),entry("ф","f"),entry("Ч","CH"),entry("ч","ch"),entry("Ц","C"),entry("ц","c"),entry("Ю","JU"),entry("ю","ju"),entry("Я","JA"),entry("я","ja"),entry("Й","J"),entry("й","j"),entry("Ь","J"),entry("ь","j"),entry("’","'"),entry("Ё","JOW"),entry("ё","jow"),entry("Ў","UH"),entry("ў","uh"),entry("Ъ","OH"),entry("ъ","oh"),entry("Ы","YW"),entry("ы","yw"),entry("Э","EHW"),entry("э","ehw")
                )
            );
            this._tr1 = (match) -> {
                for (int i = match.groupCount(); i > 0; i -= 1) {
                    String value = match.group(i);
                    if (value != null) {
                        return _maps1.get(i-1).getOrDefault(value, value);
                    }
                }
                return match.group();
            };
        }

        @Override
        public String transform(String text) {
            text = Normalizer.normalize(text, Normalizer.Form.NFC);
            text = this._rx1.matcher(text).replaceAll(this._tr1);
            text = Normalizer.normalize(text, Normalizer.Form.NFC);
            return text;
        }
    }

    private static class _Uklatn_uk_uk_Latn_KMU_55 implements _UKLatnTransformer {
        private Pattern _rx1;
        private Function<MatchResult,String> _tr1;
        private Pattern _rx2;
        private Function<MatchResult,String> _tr2;

        _Uklatn_uk_uk_Latn_KMU_55() {
            this._rx1 = Pattern.compile("(?<=[ЁЄІЇЎА-яёєіїўҐґ])([’\\u0027])(?=[ЁЄІЇЎА-яёєіїўҐґ])", Pattern.UNICODE_CHARACTER_CLASS);
            List<Map<String,String>> _maps1 = List.of(
                Map.ofEntries(
                    entry("’",""),entry("'","")
                )
            );
            this._tr1 = (match) -> {
                for (int i = match.groupCount(); i > 0; i -= 1) {
                    String value = match.group(i);
                    if (value != null) {
                        return _maps1.get(i-1).getOrDefault(value, value);
                    }
                }
                return match.group();
            };
            this._rx2 = Pattern.compile("\\b([ЄЇЮЯ])(?=\\u0301?[а-яёєіїўґ’])|\\b([ЙйЄЇЮЯєїюя])|([Зз]Г|[ЖХЦЩШЧЄЇЮЯ])(?=\\u0301?[а-яёєіїўґ’])|([Зз][Гг]|[ЄІЇА-ЩЬЮ-щьюяєіїҐґ’])", Pattern.UNICODE_CHARACTER_CLASS);
            List<Map<String,String>> _maps2 = List.of(
                Map.ofEntries(
                    entry("Є","Ye"),entry("Ї","Yi"),entry("Ю","Yu"),entry("Я","Ya")
                ),
                Map.ofEntries(
                    entry("Й","Y"),entry("й","y"),entry("Є","YE"),entry("є","ye"),entry("Ї","YI"),entry("ї","yi"),entry("Ю","YU"),entry("ю","yu"),entry("Я","YA"),entry("я","ya")
                ),
                Map.ofEntries(
                    entry("ЗГ","ZGh"),entry("зГ","zGh"),entry("Ж","Zh"),entry("Х","Kh"),entry("Ц","Ts"),entry("Щ","Shch"),entry("Ш","Sh"),entry("Ч","Ch"),entry("Є","Ie"),entry("Ї","I"),entry("Ю","Iu"),entry("Я","Ia")
                ),
                Map.ofEntries(
                    entry("ЗГ","ZGH"),entry("Зг","Zgh"),entry("зГ","zGH"),entry("зг","zgh"),entry("А","A"),entry("а","a"),entry("Б","B"),entry("б","b"),entry("В","V"),entry("в","v"),entry("Г","H"),entry("г","h"),entry("Ґ","G"),entry("ґ","g"),entry("Д","D"),entry("д","d"),entry("Е","E"),entry("е","e"),entry("Є","IE"),entry("є","ie"),entry("Ж","ZH"),entry("ж","zh"),entry("З","Z"),entry("з","z"),entry("И","Y"),entry("и","y"),entry("І","I"),entry("і","i"),entry("Ї","I"),entry("ї","i"),entry("Х","KH"),entry("х","kh"),entry("К","K"),entry("к","k"),entry("Л","L"),entry("л","l"),entry("М","M"),entry("м","m"),entry("Н","N"),entry("н","n"),entry("О","O"),entry("о","o"),entry("П","P"),entry("п","p"),entry("Р","R"),entry("р","r"),entry("Щ","SHCH"),entry("щ","shch"),entry("Ш","SH"),entry("ш","sh"),entry("С","S"),entry("с","s"),entry("Т","T"),entry("т","t"),entry("У","U"),entry("у","u"),entry("Ф","F"),entry("ф","f"),entry("Ч","CH"),entry("ч","ch"),entry("Ц","TS"),entry("ц","ts"),entry("Ю","IU"),entry("ю","iu"),entry("Я","IA"),entry("я","ia"),entry("Й","I"),entry("й","i"),entry("Ь",""),entry("ь",""),entry("’","")
                )
            );
            this._tr2 = (match) -> {
                for (int i = match.groupCount(); i > 0; i -= 1) {
                    String value = match.group(i);
                    if (value != null) {
                        return _maps2.get(i-1).getOrDefault(value, value);
                    }
                }
                return match.group();
            };
        }

        @Override
        public String transform(String text) {
            text = Normalizer.normalize(text, Normalizer.Form.NFC);
            text = this._rx1.matcher(text).replaceAll(this._tr1);
            text = this._rx2.matcher(text).replaceAll(this._tr2);
            text = Normalizer.normalize(text, Normalizer.Form.NFC);
            return text;
        }
    }

    private static class _Uklatn_uk_Latn_DSTU_9112_A_uk implements _UKLatnTransformer {
        private Pattern _rx1;
        private Function<MatchResult,String> _tr1;
        private Pattern _rx2;
        private Function<MatchResult,String> _tr2;

        _Uklatn_uk_Latn_DSTU_9112_A_uk() {
            this._rx1 = Pattern.compile("([ÁáÉéÍíÓóÚúÝýḮḯ])", Pattern.UNICODE_CHARACTER_CLASS);
            List<Map<String,String>> _maps1 = List.of(
                Map.ofEntries(
                    entry("Á","Á"),entry("á","á"),entry("É","É"),entry("é","é"),entry("Í","Í"),entry("í","í"),entry("Ó","Ó"),entry("ó","ó"),entry("Ú","Ú"),entry("ú","ú"),entry("Ý","Ý"),entry("ý","ý"),entry("Ḯ","Ḯ"),entry("ḯ","ḯ")
                )
            );
            this._tr1 = (match) -> {
                for (int i = match.groupCount(); i > 0; i -= 1) {
                    String value = match.group(i);
                    if (value != null) {
                        return _maps1.get(i-1).getOrDefault(value, value);
                    }
                }
                return match.group();
            };
            this._rx2 = Pattern.compile("(J[Ee]|j[Ee]|J[Uu]|j[Uu]|J[Aa]|j[Aa]|[A-GIK-PR-VXYZa-gik-pr-vxyzÏÖïöČčĒēĞğĴĵŜŝŠšŬŭŽžǑǒȲȳ])|(?<=[BbCcDdFfGgKkLlMmNnPpRrSsTtVvXxZzČčĞğŜŝŠšŽž])([Jj]\\u0027(?=[AaEeUu])|[Jj])|(\\u0027[Jj](?![AaEeIiUu])|\\u0027(?=[Jj])|[Jj])", Pattern.UNICODE_CHARACTER_CLASS);
            List<Map<String,String>> _maps2 = List.of(
                Map.ofEntries(
                    entry("A","А"),entry("a","а"),entry("B","Б"),entry("b","б"),entry("V","В"),entry("v","в"),entry("Ğ","Г"),entry("ğ","г"),entry("G","Ґ"),entry("g","ґ"),entry("D","Д"),entry("d","д"),entry("E","Е"),entry("e","е"),entry("JE","Є"),entry("Je","Є"),entry("jE","є"),entry("je","є"),entry("Ž","Ж"),entry("ž","ж"),entry("Z","З"),entry("z","з"),entry("Y","И"),entry("y","и"),entry("I","І"),entry("i","і"),entry("Ï","Ї"),entry("ï","ї"),entry("K","К"),entry("k","к"),entry("L","Л"),entry("l","л"),entry("M","М"),entry("m","м"),entry("N","Н"),entry("n","н"),entry("O","О"),entry("o","о"),entry("P","П"),entry("p","п"),entry("R","Р"),entry("r","р"),entry("S","С"),entry("s","с"),entry("T","Т"),entry("t","т"),entry("U","У"),entry("u","у"),entry("F","Ф"),entry("f","ф"),entry("X","Х"),entry("x","х"),entry("C","Ц"),entry("c","ц"),entry("Č","Ч"),entry("č","ч"),entry("Š","Ш"),entry("š","ш"),entry("Ŝ","Щ"),entry("ŝ","щ"),entry("JU","Ю"),entry("Ju","Ю"),entry("jU","ю"),entry("ju","ю"),entry("JA","Я"),entry("Ja","Я"),entry("jA","я"),entry("ja","я"),entry("Ĵ","Ь"),entry("ĵ","ь"),entry("Ö","Ё"),entry("ö","ё"),entry("Ŭ","Ў"),entry("ŭ","ў"),entry("Ǒ","Ъ"),entry("ǒ","ъ"),entry("Ȳ","Ы"),entry("ȳ","ы"),entry("Ē","Э"),entry("ē","э")
                ),
                Map.ofEntries(
                    entry("J","Ь"),entry("j","ь"),entry("J'","Ь"),entry("j'","ь")
                ),
                Map.ofEntries(
                    entry("'J","Й"),entry("'j","й"),entry("'","’"),entry("J","Й"),entry("j","й")
                )
            );
            this._tr2 = (match) -> {
                for (int i = match.groupCount(); i > 0; i -= 1) {
                    String value = match.group(i);
                    if (value != null) {
                        return _maps2.get(i-1).getOrDefault(value, value);
                    }
                }
                return match.group();
            };
        }

        @Override
        public String transform(String text) {
            text = Normalizer.normalize(text, Normalizer.Form.NFC);
            text = this._rx1.matcher(text).replaceAll(this._tr1);
            text = this._rx2.matcher(text).replaceAll(this._tr2);
            text = Normalizer.normalize(text, Normalizer.Form.NFC);
            return text;
        }
    }

    private static class _Uklatn_uk_Latn_DSTU_9112_B_uk implements _UKLatnTransformer {
        private Pattern _rx1;
        private Function<MatchResult,String> _tr1;
        private Pattern _rx2;
        private Function<MatchResult,String> _tr2;

        _Uklatn_uk_Latn_DSTU_9112_B_uk() {
            this._rx1 = Pattern.compile("([ÁáÉéÍíÓóÚúÝý])", Pattern.UNICODE_CHARACTER_CLASS);
            List<Map<String,String>> _maps1 = List.of(
                Map.ofEntries(
                    entry("Á","Á"),entry("á","á"),entry("É","É"),entry("é","é"),entry("Í","Í"),entry("í","í"),entry("Ó","Ó"),entry("ó","ó"),entry("Ú","Ú"),entry("ú","ú"),entry("Ý","Ý"),entry("ý","ý")
                )
            );
            this._tr1 = (match) -> {
                for (int i = match.groupCount(); i > 0; i -= 1) {
                    String value = match.group(i);
                    if (value != null) {
                        return _maps1.get(i-1).getOrDefault(value, value);
                    }
                }
                return match.group();
            };
            this._rx2 = Pattern.compile("([Jj][Oo][Ww]|[Ss][Hh][Cc][Hh]|[CcGgKkSsZzUuOo][Hh]|[Yy][Ww]|[Ee][Hh][Ww]|[Jj][EeIiUuAa]|[Hh][Jj]|[A-GIK-PR-VYZa-gik-pr-vyz])|(?<=[Ss][Hh][Cc][Hh])([Jj]\\u0027(?=[AaEeIiUu])|[Jj])|(?<=[CcGgKkSsZz][Hh])([Jj]\\u0027(?=[AaEeIiUu])|[Jj])|(?<=[BCDFGKLMNPRSTVZbcdfgklmnprstvzv])([Jj]\\u0027(?=[AaEeIiUu])|[Jj])|(\\u0027[Jj](?![AaEeIiUu])|\\u0027(?=[Jj])|[Jj])", Pattern.UNICODE_CHARACTER_CLASS);
            List<Map<String,String>> _maps2 = List.of(
                Map.ofEntries(
                    entry("A","А"),entry("a","а"),entry("B","Б"),entry("b","б"),entry("V","В"),entry("v","в"),entry("GH","Г"),entry("Gh","Г"),entry("gH","г"),entry("gh","г"),entry("G","Ґ"),entry("g","ґ"),entry("D","Д"),entry("d","д"),entry("E","Е"),entry("e","е"),entry("JE","Є"),entry("Je","Є"),entry("jE","є"),entry("je","є"),entry("ZH","Ж"),entry("Zh","Ж"),entry("zH","ж"),entry("zh","ж"),entry("Z","З"),entry("z","з"),entry("Y","И"),entry("y","и"),entry("I","І"),entry("i","і"),entry("JI","Ї"),entry("Ji","Ї"),entry("jI","ї"),entry("ji","ї"),entry("KH","Х"),entry("Kh","Х"),entry("kH","х"),entry("kh","х"),entry("K","К"),entry("k","к"),entry("L","Л"),entry("l","л"),entry("M","М"),entry("m","м"),entry("N","Н"),entry("n","н"),entry("O","О"),entry("o","о"),entry("P","П"),entry("p","п"),entry("R","Р"),entry("r","р"),entry("SHCH","Щ"),entry("SHCh","Щ"),entry("SHcH","Щ"),entry("SHch","Щ"),entry("ShCH","Щ"),entry("ShCh","Щ"),entry("ShcH","Щ"),entry("Shch","Щ"),entry("sHCH","щ"),entry("sHCh","щ"),entry("sHcH","щ"),entry("sHch","щ"),entry("shCH","щ"),entry("shCh","щ"),entry("shcH","щ"),entry("shch","щ"),entry("SH","Ш"),entry("Sh","Ш"),entry("sH","ш"),entry("sh","ш"),entry("S","С"),entry("s","с"),entry("T","Т"),entry("t","т"),entry("U","У"),entry("u","у"),entry("F","Ф"),entry("f","ф"),entry("CH","Ч"),entry("Ch","Ч"),entry("cH","ч"),entry("ch","ч"),entry("C","Ц"),entry("c","ц"),entry("JU","Ю"),entry("Ju","Ю"),entry("jU","ю"),entry("ju","ю"),entry("JA","Я"),entry("Ja","Я"),entry("jA","я"),entry("ja","я"),entry("HJ","Ь"),entry("Hj","Ь"),entry("hJ","ь"),entry("hj","ь"),entry("JOW","Ё"),entry("JOw","Ё"),entry("JoW","Ё"),entry("Jow","Ё"),entry("jOW","ё"),entry("jOw","ё"),entry("joW","ё"),entry("jow","ё"),entry("UH","Ў"),entry("Uh","Ў"),entry("uH","ў"),entry("uh","ў"),entry("OH","Ъ"),entry("Oh","Ъ"),entry("oH","ъ"),entry("oh","ъ"),entry("YW","Ы"),entry("Yw","Ы"),entry("yW","ы"),entry("yw","ы"),entry("EHW","Э"),entry("EHw","Э"),entry("EhW","Э"),entry("Ehw","Э"),entry("eHW","э"),entry("eHw","э"),entry("ehW","э"),entry("ehw","э")
                ),
                Map.ofEntries(
                    entry("J","Ь"),entry("j","ь"),entry("J'","Ь"),entry("j'","ь")
                ),
                Map.ofEntries(
                    entry("J","Ь"),entry("j","ь"),entry("J'","Ь"),entry("j'","ь")
                ),
                Map.ofEntries(
                    entry("J","Ь"),entry("j","ь"),entry("J'","Ь"),entry("j'","ь")
                ),
                Map.ofEntries(
                    entry("'J","Й"),entry("'j","й"),entry("'","’"),entry("J","Й"),entry("j","й")
                )
            );
            this._tr2 = (match) -> {
                for (int i = match.groupCount(); i > 0; i -= 1) {
                    String value = match.group(i);
                    if (value != null) {
                        return _maps2.get(i-1).getOrDefault(value, value);
                    }
                }
                return match.group();
            };
        }

        @Override
        public String transform(String text) {
            text = Normalizer.normalize(text, Normalizer.Form.NFC);
            text = this._rx1.matcher(text).replaceAll(this._tr1);
            text = this._rx2.matcher(text).replaceAll(this._tr2);
            text = Normalizer.normalize(text, Normalizer.Form.NFC);
            return text;
        }
    }

    private static _UKLatnTransformer[][] _UklatnTables = {
        {null, null},
        {new _Uklatn_uk_uk_Latn_DSTU_9112_A(), new _Uklatn_uk_Latn_DSTU_9112_A_uk()},
        {new _Uklatn_uk_uk_Latn_DSTU_9112_B(), new _Uklatn_uk_Latn_DSTU_9112_B_uk()},
        {new _Uklatn_uk_uk_Latn_KMU_55(), null},
    };
}
