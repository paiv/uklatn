// Generated by gentables.py, do not edit.

//! Ukrainian Cyrillic transliteration to and from Latin script.
//!
//! Tables:
//! - DSTU 9112:2021 System A
//! - DSTU 9112:2021 System B
//! - KMU 55:2010, not reversible
//!
//! # Examples
//! ```
//! let s = uklatn::encode("Доброго вечора!", uklatn::Table::default());
//! assert_eq!(s, "Dobroğo večora!");
//! ```
//! ```
//! let s = uklatn::decode("Paljanycja", uklatn::Table::default());
//! assert_eq!(s, "Паляниця");
//! ```
//!
//! Select a transliteration scheme:
//! ```
//! let s = uklatn::encode("Борщ", uklatn::Table::Dstu9112B);
//! assert_eq!(s, "Borshch");
//! ```
//!
use {
    fancy_regex::Captures, fancy_regex::Regex, once_cell::sync::Lazy,
    unicode_normalization::UnicodeNormalization,
};

#[derive(Default, Debug)]
pub enum Table {
    /// DSTU 9112:2021 System A
    #[default]
    Dstu9112A = 1,
    /// DSTU 9112:2021 System B
    Dstu9112B = 2,
    /// KMU 55:2010, not reversible
    Kmu55 = 3,
}

/// Transliterates a string of Ukrainian Cyrillic to Latin script.
///
/// # Examples
/// ```
/// let s = uklatn::encode("Доброго вечора!", uklatn::Table::default());
/// assert_eq!(s, "Dobroğo večora!");
/// ```
/// ```
/// let s = uklatn::encode("Шевченко", uklatn::Table::Kmu55);
/// assert_eq!(s, "Shevchenko");
/// ```
pub fn encode(text: &str, table: Table) -> String {
    match table {
        Table::Dstu9112A => encode_dstu9112a(text),
        Table::Dstu9112B => encode_dstu9112b(text),
        Table::Kmu55 => encode_kmu55(text),
    }
}

/// Re-transliterates a string of Ukrainian Latin to Cyrillic script.
///
/// # Examples
/// ```
/// let s = uklatn::decode("Paljanycja", uklatn::Table::default());
/// assert_eq!(s, "Паляниця");
/// ```
/// ```
/// let s = uklatn::decode("Shevchenko", uklatn::Table::Dstu9112B);
/// assert_eq!(s, "Шевченко");
/// ```
///
pub fn decode(text: &str, table: Table) -> String {
    match table {
        Table::Dstu9112A => decode_dstu9112a(text),
        Table::Dstu9112B => decode_dstu9112b(text),
        Table::Kmu55 => panic!("invalid table {:?}", table),
    }
}

fn encode_dstu9112a(text: &str) -> String {
    static RX1: Lazy<Regex> = Lazy::new(|| {
        let rx: &str = r"\b([Ьь])|([Ьь](?=[АаЕеУу])|[ЄЮЯ](?=\u0301?[а-щьюяєіїґ’])|(?<=[Б-ДЖЗК-НП-ТФ-Щб-джзк-нп-тф-щҐґ])[Йй])|([ЁЄІЇЎА-яёєіїўҐґ’])";
        Regex::new(rx).unwrap()
    });
    static M11: &[(&str, &str); 2] = &[("Ь", "Ĵ"), ("ь", "ĵ")];
    static M12: &[(&str, &str); 7] = &[
        ("Ь", "J'"),
        ("ь", "j'"),
        ("Є", "Je"),
        ("Ю", "Ju"),
        ("Я", "Ja"),
        ("Й", "'J"),
        ("й", "'j"),
    ];
    static M13: &[(&str, &str); 77] = &[
        ("А", "A"),
        ("а", "a"),
        ("Б", "B"),
        ("б", "b"),
        ("В", "V"),
        ("в", "v"),
        ("Г", "Ğ"),
        ("г", "ğ"),
        ("Ґ", "G"),
        ("ґ", "g"),
        ("Д", "D"),
        ("д", "d"),
        ("Е", "E"),
        ("е", "e"),
        ("Є", "JE"),
        ("є", "je"),
        ("Ж", "Ž"),
        ("ж", "ž"),
        ("З", "Z"),
        ("з", "z"),
        ("И", "Y"),
        ("и", "y"),
        ("І", "I"),
        ("і", "i"),
        ("Ї", "Ï"),
        ("ї", "ï"),
        ("К", "K"),
        ("к", "k"),
        ("Л", "L"),
        ("л", "l"),
        ("М", "M"),
        ("м", "m"),
        ("Н", "N"),
        ("н", "n"),
        ("О", "O"),
        ("о", "o"),
        ("П", "P"),
        ("п", "p"),
        ("Р", "R"),
        ("р", "r"),
        ("С", "S"),
        ("с", "s"),
        ("Т", "T"),
        ("т", "t"),
        ("У", "U"),
        ("у", "u"),
        ("Ф", "F"),
        ("ф", "f"),
        ("Х", "X"),
        ("х", "x"),
        ("Ц", "C"),
        ("ц", "c"),
        ("Ч", "Č"),
        ("ч", "č"),
        ("Ш", "Š"),
        ("ш", "š"),
        ("Щ", "Ŝ"),
        ("щ", "ŝ"),
        ("Ю", "JU"),
        ("ю", "ju"),
        ("Я", "JA"),
        ("я", "ja"),
        ("Ь", "J"),
        ("ь", "j"),
        ("Й", "J"),
        ("й", "j"),
        ("’", "'"),
        ("Ё", "Ö"),
        ("ё", "ö"),
        ("Ў", "Ŭ"),
        ("ў", "ŭ"),
        ("Ъ", "Ǒ"),
        ("ъ", "ǒ"),
        ("Ы", "Ȳ"),
        ("ы", "ȳ"),
        ("Э", "Ē"),
        ("э", "ē"),
    ];

    let tr1 = |caps: &Captures| -> String {
        if let Some(m) = caps.get(1) {
            let s = m.as_str();
            for p in M11 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else if let Some(m) = caps.get(2) {
            let s = m.as_str();
            for p in M12 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else if let Some(m) = caps.get(3) {
            let s = m.as_str();
            for p in M13 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else {
            caps[0].to_string()
        }
    };
    let text = text.nfc().collect::<String>();
    let text = RX1.replace_all(&text, tr1);
    let text = text.nfc().collect::<String>();
    text
}

fn encode_dstu9112b(text: &str) -> String {
    static RX1: Lazy<Regex> = Lazy::new(|| {
        let rx: &str = r"([Ьь](?=[АаЕеІіУу])|(?<=[Б-ДЖЗК-НП-ТФ-Щб-джзк-нп-тф-щҐґ])[Йй])|([ГЄЖЇХЩШЧЮЯЁЎЪЫЭ](?=\u0301?[а-яёєіїўґ’])|\b[Ьь])|([ЁЄІЇЎА-яёєіїўҐґ’])";
        Regex::new(rx).unwrap()
    });
    static M11: &[(&str, &str); 4] = &[("Ь", "J'"), ("ь", "j'"), ("Й", "'J"), ("й", "'j")];
    static M12: &[(&str, &str); 17] = &[
        ("Г", "Gh"),
        ("Є", "Je"),
        ("Ж", "Zh"),
        ("Ї", "Ji"),
        ("Х", "Kh"),
        ("Щ", "Shch"),
        ("Ш", "Sh"),
        ("Ч", "Ch"),
        ("Ю", "Ju"),
        ("Я", "Ja"),
        ("Ё", "Jow"),
        ("Ў", "Uh"),
        ("Ъ", "Oh"),
        ("Ы", "Yw"),
        ("Э", "Ehw"),
        ("Ь", "Hj"),
        ("ь", "hj"),
    ];
    static M13: &[(&str, &str); 77] = &[
        ("А", "A"),
        ("а", "a"),
        ("Б", "B"),
        ("б", "b"),
        ("В", "V"),
        ("в", "v"),
        ("Г", "GH"),
        ("г", "gh"),
        ("Ґ", "G"),
        ("ґ", "g"),
        ("Д", "D"),
        ("д", "d"),
        ("Е", "E"),
        ("е", "e"),
        ("Є", "JE"),
        ("є", "je"),
        ("Ж", "ZH"),
        ("ж", "zh"),
        ("З", "Z"),
        ("з", "z"),
        ("И", "Y"),
        ("и", "y"),
        ("І", "I"),
        ("і", "i"),
        ("Ї", "JI"),
        ("ї", "ji"),
        ("Х", "KH"),
        ("х", "kh"),
        ("К", "K"),
        ("к", "k"),
        ("Л", "L"),
        ("л", "l"),
        ("М", "M"),
        ("м", "m"),
        ("Н", "N"),
        ("н", "n"),
        ("О", "O"),
        ("о", "o"),
        ("П", "P"),
        ("п", "p"),
        ("Р", "R"),
        ("р", "r"),
        ("Щ", "SHCH"),
        ("щ", "shch"),
        ("Ш", "SH"),
        ("ш", "sh"),
        ("С", "S"),
        ("с", "s"),
        ("Т", "T"),
        ("т", "t"),
        ("У", "U"),
        ("у", "u"),
        ("Ф", "F"),
        ("ф", "f"),
        ("Ч", "CH"),
        ("ч", "ch"),
        ("Ц", "C"),
        ("ц", "c"),
        ("Ю", "JU"),
        ("ю", "ju"),
        ("Я", "JA"),
        ("я", "ja"),
        ("Й", "J"),
        ("й", "j"),
        ("Ь", "J"),
        ("ь", "j"),
        ("’", "'"),
        ("Ё", "JOW"),
        ("ё", "jow"),
        ("Ў", "UH"),
        ("ў", "uh"),
        ("Ъ", "OH"),
        ("ъ", "oh"),
        ("Ы", "YW"),
        ("ы", "yw"),
        ("Э", "EHW"),
        ("э", "ehw"),
    ];

    let tr1 = |caps: &Captures| -> String {
        if let Some(m) = caps.get(1) {
            let s = m.as_str();
            for p in M11 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else if let Some(m) = caps.get(2) {
            let s = m.as_str();
            for p in M12 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else if let Some(m) = caps.get(3) {
            let s = m.as_str();
            for p in M13 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else {
            caps[0].to_string()
        }
    };
    let text = text.nfc().collect::<String>();
    let text = RX1.replace_all(&text, tr1);
    let text = text.nfc().collect::<String>();
    text
}

fn encode_kmu55(text: &str) -> String {
    static RX1: Lazy<Regex> = Lazy::new(|| {
        let rx: &str = r"(?<=[ЁЄІЇЎА-яёєіїўҐґ])([’\u0027])(?=[ЁЄІЇЎА-яёєіїўҐґ])";
        Regex::new(rx).unwrap()
    });
    static M11: &[(&str, &str); 2] = &[("’", ""), ("'", "")];

    let tr1 = |caps: &Captures| -> String {
        if let Some(m) = caps.get(1) {
            let s = m.as_str();
            for p in M11 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else {
            caps[0].to_string()
        }
    };
    static RX2: Lazy<Regex> = Lazy::new(|| {
        let rx: &str = r"\b([ЄЇЮЯ])(?=\u0301?[а-яёєіїўґ’])|\b([ЙйЄЇЮЯєїюя])|([Зз]Г|[ЖХЦЩШЧЄЇЮЯ])(?=\u0301?[а-яёєіїўґ’])|([Зз][Гг]|[ЄІЇА-ЩЬЮ-щьюяєіїҐґ’])";
        Regex::new(rx).unwrap()
    });
    static M21: &[(&str, &str); 4] = &[("Є", "Ye"), ("Ї", "Yi"), ("Ю", "Yu"), ("Я", "Ya")];
    static M22: &[(&str, &str); 10] = &[
        ("Й", "Y"),
        ("й", "y"),
        ("Є", "YE"),
        ("є", "ye"),
        ("Ї", "YI"),
        ("ї", "yi"),
        ("Ю", "YU"),
        ("ю", "yu"),
        ("Я", "YA"),
        ("я", "ya"),
    ];
    static M23: &[(&str, &str); 12] = &[
        ("ЗГ", "ZGh"),
        ("зГ", "zGh"),
        ("Ж", "Zh"),
        ("Х", "Kh"),
        ("Ц", "Ts"),
        ("Щ", "Shch"),
        ("Ш", "Sh"),
        ("Ч", "Ch"),
        ("Є", "Ie"),
        ("Ї", "I"),
        ("Ю", "Iu"),
        ("Я", "Ia"),
    ];
    static M24: &[(&str, &str); 71] = &[
        ("ЗГ", "ZGH"),
        ("Зг", "Zgh"),
        ("зГ", "zGH"),
        ("зг", "zgh"),
        ("А", "A"),
        ("а", "a"),
        ("Б", "B"),
        ("б", "b"),
        ("В", "V"),
        ("в", "v"),
        ("Г", "H"),
        ("г", "h"),
        ("Ґ", "G"),
        ("ґ", "g"),
        ("Д", "D"),
        ("д", "d"),
        ("Е", "E"),
        ("е", "e"),
        ("Є", "IE"),
        ("є", "ie"),
        ("Ж", "ZH"),
        ("ж", "zh"),
        ("З", "Z"),
        ("з", "z"),
        ("И", "Y"),
        ("и", "y"),
        ("І", "I"),
        ("і", "i"),
        ("Ї", "I"),
        ("ї", "i"),
        ("Х", "KH"),
        ("х", "kh"),
        ("К", "K"),
        ("к", "k"),
        ("Л", "L"),
        ("л", "l"),
        ("М", "M"),
        ("м", "m"),
        ("Н", "N"),
        ("н", "n"),
        ("О", "O"),
        ("о", "o"),
        ("П", "P"),
        ("п", "p"),
        ("Р", "R"),
        ("р", "r"),
        ("Щ", "SHCH"),
        ("щ", "shch"),
        ("Ш", "SH"),
        ("ш", "sh"),
        ("С", "S"),
        ("с", "s"),
        ("Т", "T"),
        ("т", "t"),
        ("У", "U"),
        ("у", "u"),
        ("Ф", "F"),
        ("ф", "f"),
        ("Ч", "CH"),
        ("ч", "ch"),
        ("Ц", "TS"),
        ("ц", "ts"),
        ("Ю", "IU"),
        ("ю", "iu"),
        ("Я", "IA"),
        ("я", "ia"),
        ("Й", "I"),
        ("й", "i"),
        ("Ь", ""),
        ("ь", ""),
        ("’", ""),
    ];

    let tr2 = |caps: &Captures| -> String {
        if let Some(m) = caps.get(1) {
            let s = m.as_str();
            for p in M21 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else if let Some(m) = caps.get(2) {
            let s = m.as_str();
            for p in M22 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else if let Some(m) = caps.get(3) {
            let s = m.as_str();
            for p in M23 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else if let Some(m) = caps.get(4) {
            let s = m.as_str();
            for p in M24 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else {
            caps[0].to_string()
        }
    };
    let text = text.nfc().collect::<String>();
    let text = RX1.replace_all(&text, tr1);
    let text = RX2.replace_all(&text, tr2);
    let text = text.nfc().collect::<String>();
    text
}

fn decode_dstu9112a(text: &str) -> String {
    static RX1: Lazy<Regex> = Lazy::new(|| {
        let rx: &str = r"([ÁáÉéÍíÓóÚúÝýḮḯ])";
        Regex::new(rx).unwrap()
    });
    static M11: &[(&str, &str); 14] = &[
        ("Á", "Á"),
        ("á", "á"),
        ("É", "É"),
        ("é", "é"),
        ("Í", "Í"),
        ("í", "í"),
        ("Ó", "Ó"),
        ("ó", "ó"),
        ("Ú", "Ú"),
        ("ú", "ú"),
        ("Ý", "Ý"),
        ("ý", "ý"),
        ("Ḯ", "Ḯ"),
        ("ḯ", "ḯ"),
    ];

    let tr1 = |caps: &Captures| -> String {
        if let Some(m) = caps.get(1) {
            let s = m.as_str();
            for p in M11 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else {
            caps[0].to_string()
        }
    };
    static RX2: Lazy<Regex> = Lazy::new(|| {
        let rx: &str = r"(J[Ee]|j[Ee]|J[Uu]|j[Uu]|J[Aa]|j[Aa]|[A-GIK-PR-VXYZa-gik-pr-vxyzÏÖïöČčĒēĞğĴĵŜŝŠšŬŭŽžǑǒȲȳ])|(?<=[BbCcDdFfGgKkLlMmNnPpRrSsTtVvXxZzČčĞğŜŝŠšŽž])([Jj]\u0027(?=[AaEeUu])|[Jj])|(\u0027[Jj](?![AaEeIiUu])|\u0027(?=[Jj])|[Jj])";
        Regex::new(rx).unwrap()
    });
    static M21: &[(&str, &str); 80] = &[
        ("A", "А"),
        ("a", "а"),
        ("B", "Б"),
        ("b", "б"),
        ("V", "В"),
        ("v", "в"),
        ("Ğ", "Г"),
        ("ğ", "г"),
        ("G", "Ґ"),
        ("g", "ґ"),
        ("D", "Д"),
        ("d", "д"),
        ("E", "Е"),
        ("e", "е"),
        ("JE", "Є"),
        ("Je", "Є"),
        ("jE", "є"),
        ("je", "є"),
        ("Ž", "Ж"),
        ("ž", "ж"),
        ("Z", "З"),
        ("z", "з"),
        ("Y", "И"),
        ("y", "и"),
        ("I", "І"),
        ("i", "і"),
        ("Ï", "Ї"),
        ("ï", "ї"),
        ("K", "К"),
        ("k", "к"),
        ("L", "Л"),
        ("l", "л"),
        ("M", "М"),
        ("m", "м"),
        ("N", "Н"),
        ("n", "н"),
        ("O", "О"),
        ("o", "о"),
        ("P", "П"),
        ("p", "п"),
        ("R", "Р"),
        ("r", "р"),
        ("S", "С"),
        ("s", "с"),
        ("T", "Т"),
        ("t", "т"),
        ("U", "У"),
        ("u", "у"),
        ("F", "Ф"),
        ("f", "ф"),
        ("X", "Х"),
        ("x", "х"),
        ("C", "Ц"),
        ("c", "ц"),
        ("Č", "Ч"),
        ("č", "ч"),
        ("Š", "Ш"),
        ("š", "ш"),
        ("Ŝ", "Щ"),
        ("ŝ", "щ"),
        ("JU", "Ю"),
        ("Ju", "Ю"),
        ("jU", "ю"),
        ("ju", "ю"),
        ("JA", "Я"),
        ("Ja", "Я"),
        ("jA", "я"),
        ("ja", "я"),
        ("Ĵ", "Ь"),
        ("ĵ", "ь"),
        ("Ö", "Ё"),
        ("ö", "ё"),
        ("Ŭ", "Ў"),
        ("ŭ", "ў"),
        ("Ǒ", "Ъ"),
        ("ǒ", "ъ"),
        ("Ȳ", "Ы"),
        ("ȳ", "ы"),
        ("Ē", "Э"),
        ("ē", "э"),
    ];
    static M22: &[(&str, &str); 4] = &[("J", "Ь"), ("j", "ь"), ("J'", "Ь"), ("j'", "ь")];
    static M23: &[(&str, &str); 5] =
        &[("'J", "Й"), ("'j", "й"), ("'", "’"), ("J", "Й"), ("j", "й")];

    let tr2 = |caps: &Captures| -> String {
        if let Some(m) = caps.get(1) {
            let s = m.as_str();
            for p in M21 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else if let Some(m) = caps.get(2) {
            let s = m.as_str();
            for p in M22 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else if let Some(m) = caps.get(3) {
            let s = m.as_str();
            for p in M23 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else {
            caps[0].to_string()
        }
    };
    let text = text.nfc().collect::<String>();
    let text = RX1.replace_all(&text, tr1);
    let text = RX2.replace_all(&text, tr2);
    let text = text.nfc().collect::<String>();
    text
}

fn decode_dstu9112b(text: &str) -> String {
    static RX1: Lazy<Regex> = Lazy::new(|| {
        let rx: &str = r"([ÁáÉéÍíÓóÚúÝý])";
        Regex::new(rx).unwrap()
    });
    static M11: &[(&str, &str); 12] = &[
        ("Á", "Á"),
        ("á", "á"),
        ("É", "É"),
        ("é", "é"),
        ("Í", "Í"),
        ("í", "í"),
        ("Ó", "Ó"),
        ("ó", "ó"),
        ("Ú", "Ú"),
        ("ú", "ú"),
        ("Ý", "Ý"),
        ("ý", "ý"),
    ];

    let tr1 = |caps: &Captures| -> String {
        if let Some(m) = caps.get(1) {
            let s = m.as_str();
            for p in M11 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else {
            caps[0].to_string()
        }
    };
    static RX2: Lazy<Regex> = Lazy::new(|| {
        let rx: &str = r"([Jj][Oo][Ww]|[Ss][Hh][Cc][Hh]|[CcGgKkSsZzUuOo][Hh]|[Yy][Ww]|[Ee][Hh][Ww]|[Jj][EeIiUuAa]|[Hh][Jj]|[A-GIK-PR-VYZa-gik-pr-vyz])|(?<=[Ss][Hh][Cc][Hh])([Jj]\u0027(?=[AaEeIiUu])|[Jj])|(?<=[CcGgKkSsZz][Hh])([Jj]\u0027(?=[AaEeIiUu])|[Jj])|(?<=[BCDFGKLMNPRSTVZbcdfgklmnprstvzv])([Jj]\u0027(?=[AaEeIiUu])|[Jj])|(\u0027[Jj](?![AaEeIiUu])|\u0027(?=[Jj])|[Jj])";
        Regex::new(rx).unwrap()
    });
    static M21: &[(&str, &str); 126] = &[
        ("A", "А"),
        ("a", "а"),
        ("B", "Б"),
        ("b", "б"),
        ("V", "В"),
        ("v", "в"),
        ("GH", "Г"),
        ("Gh", "Г"),
        ("gH", "г"),
        ("gh", "г"),
        ("G", "Ґ"),
        ("g", "ґ"),
        ("D", "Д"),
        ("d", "д"),
        ("E", "Е"),
        ("e", "е"),
        ("JE", "Є"),
        ("Je", "Є"),
        ("jE", "є"),
        ("je", "є"),
        ("ZH", "Ж"),
        ("Zh", "Ж"),
        ("zH", "ж"),
        ("zh", "ж"),
        ("Z", "З"),
        ("z", "з"),
        ("Y", "И"),
        ("y", "и"),
        ("I", "І"),
        ("i", "і"),
        ("JI", "Ї"),
        ("Ji", "Ї"),
        ("jI", "ї"),
        ("ji", "ї"),
        ("KH", "Х"),
        ("Kh", "Х"),
        ("kH", "х"),
        ("kh", "х"),
        ("K", "К"),
        ("k", "к"),
        ("L", "Л"),
        ("l", "л"),
        ("M", "М"),
        ("m", "м"),
        ("N", "Н"),
        ("n", "н"),
        ("O", "О"),
        ("o", "о"),
        ("P", "П"),
        ("p", "п"),
        ("R", "Р"),
        ("r", "р"),
        ("SHCH", "Щ"),
        ("SHCh", "Щ"),
        ("SHcH", "Щ"),
        ("SHch", "Щ"),
        ("ShCH", "Щ"),
        ("ShCh", "Щ"),
        ("ShcH", "Щ"),
        ("Shch", "Щ"),
        ("sHCH", "щ"),
        ("sHCh", "щ"),
        ("sHcH", "щ"),
        ("sHch", "щ"),
        ("shCH", "щ"),
        ("shCh", "щ"),
        ("shcH", "щ"),
        ("shch", "щ"),
        ("SH", "Ш"),
        ("Sh", "Ш"),
        ("sH", "ш"),
        ("sh", "ш"),
        ("S", "С"),
        ("s", "с"),
        ("T", "Т"),
        ("t", "т"),
        ("U", "У"),
        ("u", "у"),
        ("F", "Ф"),
        ("f", "ф"),
        ("CH", "Ч"),
        ("Ch", "Ч"),
        ("cH", "ч"),
        ("ch", "ч"),
        ("C", "Ц"),
        ("c", "ц"),
        ("JU", "Ю"),
        ("Ju", "Ю"),
        ("jU", "ю"),
        ("ju", "ю"),
        ("JA", "Я"),
        ("Ja", "Я"),
        ("jA", "я"),
        ("ja", "я"),
        ("HJ", "Ь"),
        ("Hj", "Ь"),
        ("hJ", "ь"),
        ("hj", "ь"),
        ("JOW", "Ё"),
        ("JOw", "Ё"),
        ("JoW", "Ё"),
        ("Jow", "Ё"),
        ("jOW", "ё"),
        ("jOw", "ё"),
        ("joW", "ё"),
        ("jow", "ё"),
        ("UH", "Ў"),
        ("Uh", "Ў"),
        ("uH", "ў"),
        ("uh", "ў"),
        ("OH", "Ъ"),
        ("Oh", "Ъ"),
        ("oH", "ъ"),
        ("oh", "ъ"),
        ("YW", "Ы"),
        ("Yw", "Ы"),
        ("yW", "ы"),
        ("yw", "ы"),
        ("EHW", "Э"),
        ("EHw", "Э"),
        ("EhW", "Э"),
        ("Ehw", "Э"),
        ("eHW", "э"),
        ("eHw", "э"),
        ("ehW", "э"),
        ("ehw", "э"),
    ];
    static M22: &[(&str, &str); 4] = &[("J", "Ь"), ("j", "ь"), ("J'", "Ь"), ("j'", "ь")];
    static M23: &[(&str, &str); 4] = &[("J", "Ь"), ("j", "ь"), ("J'", "Ь"), ("j'", "ь")];
    static M24: &[(&str, &str); 4] = &[("J", "Ь"), ("j", "ь"), ("J'", "Ь"), ("j'", "ь")];
    static M25: &[(&str, &str); 5] =
        &[("'J", "Й"), ("'j", "й"), ("'", "’"), ("J", "Й"), ("j", "й")];

    let tr2 = |caps: &Captures| -> String {
        if let Some(m) = caps.get(1) {
            let s = m.as_str();
            for p in M21 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else if let Some(m) = caps.get(2) {
            let s = m.as_str();
            for p in M22 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else if let Some(m) = caps.get(3) {
            let s = m.as_str();
            for p in M23 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else if let Some(m) = caps.get(4) {
            let s = m.as_str();
            for p in M24 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else if let Some(m) = caps.get(5) {
            let s = m.as_str();
            for p in M25 {
                if p.0 == s {
                    return p.1.to_string();
                }
            }
            return s.to_string();
        } else {
            caps[0].to_string()
        }
    };
    let text = text.nfc().collect::<String>();
    let text = RX1.replace_all(&text, tr1);
    let text = RX2.replace_all(&text, tr2);
    let text = text.nfc().collect::<String>();
    text
}
