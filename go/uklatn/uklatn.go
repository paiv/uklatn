/* Generated by gentables.py, do not edit. */

// Package uklatn implements transliteration
// of Ukrainian Cyrillic to and from Latin script.
//
// Supported transliteration schemes:
//   - [DSTU 9112:2021]
//   - [KMU 55:2010] (to Latin script only)
//
// [DSTU 9112:2021]: https://uk.wikipedia.org/wiki/ДСТУ_9112:2021
// [KMU 55:2010]: https://zakon.rada.gov.ua/laws/show/55-2010-п
package uklatn

import (
	"github.com/dlclark/regexp2"
	"golang.org/x/text/unicode/norm"
)

type Table int

const (
	DefaultTable Table = iota
	DSTU_9112_A        // DSTU 9112:2021 System A
	DSTU_9112_B        // DSTU 9112:2021 System B
	KMU_55             // KMU 55:2010, not reversible
)

// EncodeString transliterates a string of Ukrainian Cyrillic to Latin script,
// given the transliteration table.
func EncodeString(s string, t Table) string {
	if t == DefaultTable {
		t = DSTU_9112_A
	}
	tr := tables[t][0]
	if tr != nil {
		return tr(s)
	}
	panic(t)
}

// DecodeString re-transliterates a string of Ukrainian Latin to Cyrillic script,
// given the transliteration table.
func DecodeString(s string, t Table) string {
	if t == DefaultTable {
		t = DSTU_9112_A
	}
	if tr := tables[t][1]; tr != nil {
		return tr(s)
	}
	panic(t)
}

func replaceAllStringSubmatchFunc(re *regexp2.Regexp, src string, repl func(int, string) string) string {
	res, err := re.ReplaceFunc(src, func(m regexp2.Match) string {
		for i := m.GroupCount() - 1; i > 0; i -= 1 {
			g := m.Groups()[i]
			if g.Capture.Length > 0 {
				s := g.Capture.String()
				return repl(i, s)
			}
		}
		return m.Group.Capture.String()
	}, -1, -1)
	if err == nil {
		return res
	}
	panic(err)
}

var table_uk_uk_Latn_DSTU_9112_A = func() func(string) string {
	rx1 := regexp2.MustCompile(`\b([Ьь])|([Ьь](?=[АаЕеУу])|[ЄЮЯ](?=\u0301?[а-щьюяєіїґ’])|(?<=[Б-ДЖЗК-НП-ТФ-Щб-джзк-нп-тф-щҐґ])[Йй])|([ЁЄІЇЎА-яёєіїўҐґ’])`, regexp2.Compiled|regexp2.Unicode)
	maps1 := [...]map[string]string{
		{"Ь": "Ĵ", "ь": "ĵ"},
		{"Ь": "J'", "ь": "j'", "Є": "Je", "Ю": "Ju", "Я": "Ja", "Й": "'J", "й": "'j"},
		{"А": "A", "а": "a", "Б": "B", "б": "b", "В": "V", "в": "v", "Г": "Ğ", "г": "ğ", "Ґ": "G", "ґ": "g", "Д": "D", "д": "d", "Е": "E", "е": "e", "Є": "JE", "є": "je", "Ж": "Ž", "ж": "ž", "З": "Z", "з": "z", "И": "Y", "и": "y", "І": "I", "і": "i", "Ї": "Ï", "ї": "ï", "К": "K", "к": "k", "Л": "L", "л": "l", "М": "M", "м": "m", "Н": "N", "н": "n", "О": "O", "о": "o", "П": "P", "п": "p", "Р": "R", "р": "r", "С": "S", "с": "s", "Т": "T", "т": "t", "У": "U", "у": "u", "Ф": "F", "ф": "f", "Х": "X", "х": "x", "Ц": "C", "ц": "c", "Ч": "Č", "ч": "č", "Ш": "Š", "ш": "š", "Щ": "Ŝ", "щ": "ŝ", "Ю": "JU", "ю": "ju", "Я": "JA", "я": "ja", "Ь": "J", "ь": "j", "Й": "J", "й": "j", "’": "'", "Ё": "Ö", "ё": "ö", "Ў": "Ŭ", "ў": "ŭ", "Ъ": "Ǒ", "ъ": "ǒ", "Ы": "Ȳ", "ы": "ȳ", "Э": "Ē", "э": "ē"},
	}
	tr1 := func(i int, s string) string {
		if v, t := maps1[i-1][s]; t {
			return v
		}
		return s
	}

	return func(text string) string {
		text = norm.NFC.String(text)
		text = replaceAllStringSubmatchFunc(rx1, text, tr1)
		text = norm.NFC.String(text)
		return text
	}
}()

var table_uk_uk_Latn_DSTU_9112_B = func() func(string) string {
	rx1 := regexp2.MustCompile(`([Ьь](?=[АаЕеІіУу])|(?<=[Б-ДЖЗК-НП-ТФ-Щб-джзк-нп-тф-щҐґ])[Йй])|([ГЄЖЇХЩШЧЮЯЁЎЪЫЭ](?=\u0301?[а-яёєіїўґ’])|\b[Ьь])|([ЁЄІЇЎА-яёєіїўҐґ’])`, regexp2.Compiled|regexp2.Unicode)
	maps1 := [...]map[string]string{
		{"Ь": "J'", "ь": "j'", "Й": "'J", "й": "'j"},
		{"Г": "Gh", "Є": "Je", "Ж": "Zh", "Ї": "Ji", "Х": "Kh", "Щ": "Shch", "Ш": "Sh", "Ч": "Ch", "Ю": "Ju", "Я": "Ja", "Ё": "Jow", "Ў": "Uh", "Ъ": "Oh", "Ы": "Yw", "Э": "Ehw", "Ь": "Hj", "ь": "hj"},
		{"А": "A", "а": "a", "Б": "B", "б": "b", "В": "V", "в": "v", "Г": "GH", "г": "gh", "Ґ": "G", "ґ": "g", "Д": "D", "д": "d", "Е": "E", "е": "e", "Є": "JE", "є": "je", "Ж": "ZH", "ж": "zh", "З": "Z", "з": "z", "И": "Y", "и": "y", "І": "I", "і": "i", "Ї": "JI", "ї": "ji", "Х": "KH", "х": "kh", "К": "K", "к": "k", "Л": "L", "л": "l", "М": "M", "м": "m", "Н": "N", "н": "n", "О": "O", "о": "o", "П": "P", "п": "p", "Р": "R", "р": "r", "Щ": "SHCH", "щ": "shch", "Ш": "SH", "ш": "sh", "С": "S", "с": "s", "Т": "T", "т": "t", "У": "U", "у": "u", "Ф": "F", "ф": "f", "Ч": "CH", "ч": "ch", "Ц": "C", "ц": "c", "Ю": "JU", "ю": "ju", "Я": "JA", "я": "ja", "Й": "J", "й": "j", "Ь": "J", "ь": "j", "’": "'", "Ё": "JOW", "ё": "jow", "Ў": "UH", "ў": "uh", "Ъ": "OH", "ъ": "oh", "Ы": "YW", "ы": "yw", "Э": "EHW", "э": "ehw"},
	}
	tr1 := func(i int, s string) string {
		if v, t := maps1[i-1][s]; t {
			return v
		}
		return s
	}

	return func(text string) string {
		text = norm.NFC.String(text)
		text = replaceAllStringSubmatchFunc(rx1, text, tr1)
		text = norm.NFC.String(text)
		return text
	}
}()

var table_uk_uk_Latn_KMU_55 = func() func(string) string {
	rx1 := regexp2.MustCompile(`(?<=[ЁЄІЇЎА-яёєіїўҐґ])([’\u0027])(?=[ЁЄІЇЎА-яёєіїўҐґ])`, regexp2.Compiled|regexp2.Unicode)
	maps1 := [...]map[string]string{
		{"’": "", "'": ""},
	}
	tr1 := func(i int, s string) string {
		if v, t := maps1[i-1][s]; t {
			return v
		}
		return s
	}
	rx2 := regexp2.MustCompile(`\b([ЄЇЮЯ])(?=\u0301?[а-яёєіїўґ’])|\b([ЙйЄЇЮЯєїюя])|([Зз]Г|[ЖХЦЩШЧЄЇЮЯ])(?=\u0301?[а-яёєіїўґ’])|([Зз][Гг]|[ЄІЇА-ЩЬЮ-щьюяєіїҐґ’])`, regexp2.Compiled|regexp2.Unicode)
	maps2 := [...]map[string]string{
		{"Є": "Ye", "Ї": "Yi", "Ю": "Yu", "Я": "Ya"},
		{"Й": "Y", "й": "y", "Є": "YE", "є": "ye", "Ї": "YI", "ї": "yi", "Ю": "YU", "ю": "yu", "Я": "YA", "я": "ya"},
		{"ЗГ": "ZGh", "зГ": "zGh", "Ж": "Zh", "Х": "Kh", "Ц": "Ts", "Щ": "Shch", "Ш": "Sh", "Ч": "Ch", "Є": "Ie", "Ї": "I", "Ю": "Iu", "Я": "Ia"},
		{"ЗГ": "ZGH", "Зг": "Zgh", "зГ": "zGH", "зг": "zgh", "А": "A", "а": "a", "Б": "B", "б": "b", "В": "V", "в": "v", "Г": "H", "г": "h", "Ґ": "G", "ґ": "g", "Д": "D", "д": "d", "Е": "E", "е": "e", "Є": "IE", "є": "ie", "Ж": "ZH", "ж": "zh", "З": "Z", "з": "z", "И": "Y", "и": "y", "І": "I", "і": "i", "Ї": "I", "ї": "i", "Х": "KH", "х": "kh", "К": "K", "к": "k", "Л": "L", "л": "l", "М": "M", "м": "m", "Н": "N", "н": "n", "О": "O", "о": "o", "П": "P", "п": "p", "Р": "R", "р": "r", "Щ": "SHCH", "щ": "shch", "Ш": "SH", "ш": "sh", "С": "S", "с": "s", "Т": "T", "т": "t", "У": "U", "у": "u", "Ф": "F", "ф": "f", "Ч": "CH", "ч": "ch", "Ц": "TS", "ц": "ts", "Ю": "IU", "ю": "iu", "Я": "IA", "я": "ia", "Й": "I", "й": "i", "Ь": "", "ь": "", "’": ""},
	}
	tr2 := func(i int, s string) string {
		if v, t := maps2[i-1][s]; t {
			return v
		}
		return s
	}

	return func(text string) string {
		text = norm.NFC.String(text)
		text = replaceAllStringSubmatchFunc(rx1, text, tr1)
		text = replaceAllStringSubmatchFunc(rx2, text, tr2)
		text = norm.NFC.String(text)
		return text
	}
}()

var table_uk_Latn_DSTU_9112_A_uk = func() func(string) string {
	rx1 := regexp2.MustCompile(`([ÁáÉéÍíÓóÚúÝýḮḯ])`, regexp2.Compiled|regexp2.Unicode)
	maps1 := [...]map[string]string{
		{"Á": "Á", "á": "á", "É": "É", "é": "é", "Í": "Í", "í": "í", "Ó": "Ó", "ó": "ó", "Ú": "Ú", "ú": "ú", "Ý": "Ý", "ý": "ý", "Ḯ": "Ḯ", "ḯ": "ḯ"},
	}
	tr1 := func(i int, s string) string {
		if v, t := maps1[i-1][s]; t {
			return v
		}
		return s
	}
	rx2 := regexp2.MustCompile(`(J[Ee]|j[Ee]|J[Uu]|j[Uu]|J[Aa]|j[Aa]|[A-GIK-PR-VXYZa-gik-pr-vxyzÏÖïöČčĒēĞğĴĵŜŝŠšŬŭŽžǑǒȲȳ])|(?<=[BbCcDdFfGgKkLlMmNnPpRrSsTtVvXxZzČčĞğŜŝŠšŽž])([Jj]\u0027(?=[AaEeUu])|[Jj])|(\u0027[Jj](?![AaEeIiUu])|\u0027(?=[Jj])|[Jj])`, regexp2.Compiled|regexp2.Unicode)
	maps2 := [...]map[string]string{
		{"A": "А", "a": "а", "B": "Б", "b": "б", "V": "В", "v": "в", "Ğ": "Г", "ğ": "г", "G": "Ґ", "g": "ґ", "D": "Д", "d": "д", "E": "Е", "e": "е", "JE": "Є", "Je": "Є", "jE": "є", "je": "є", "Ž": "Ж", "ž": "ж", "Z": "З", "z": "з", "Y": "И", "y": "и", "I": "І", "i": "і", "Ï": "Ї", "ï": "ї", "K": "К", "k": "к", "L": "Л", "l": "л", "M": "М", "m": "м", "N": "Н", "n": "н", "O": "О", "o": "о", "P": "П", "p": "п", "R": "Р", "r": "р", "S": "С", "s": "с", "T": "Т", "t": "т", "U": "У", "u": "у", "F": "Ф", "f": "ф", "X": "Х", "x": "х", "C": "Ц", "c": "ц", "Č": "Ч", "č": "ч", "Š": "Ш", "š": "ш", "Ŝ": "Щ", "ŝ": "щ", "JU": "Ю", "Ju": "Ю", "jU": "ю", "ju": "ю", "JA": "Я", "Ja": "Я", "jA": "я", "ja": "я", "Ĵ": "Ь", "ĵ": "ь", "Ö": "Ё", "ö": "ё", "Ŭ": "Ў", "ŭ": "ў", "Ǒ": "Ъ", "ǒ": "ъ", "Ȳ": "Ы", "ȳ": "ы", "Ē": "Э", "ē": "э"},
		{"J": "Ь", "j": "ь", "J'": "Ь", "j'": "ь"},
		{"'J": "Й", "'j": "й", "'": "’", "J": "Й", "j": "й"},
	}
	tr2 := func(i int, s string) string {
		if v, t := maps2[i-1][s]; t {
			return v
		}
		return s
	}

	return func(text string) string {
		text = norm.NFC.String(text)
		text = replaceAllStringSubmatchFunc(rx1, text, tr1)
		text = replaceAllStringSubmatchFunc(rx2, text, tr2)
		text = norm.NFC.String(text)
		return text
	}
}()

var table_uk_Latn_DSTU_9112_B_uk = func() func(string) string {
	rx1 := regexp2.MustCompile(`([ÁáÉéÍíÓóÚúÝý])`, regexp2.Compiled|regexp2.Unicode)
	maps1 := [...]map[string]string{
		{"Á": "Á", "á": "á", "É": "É", "é": "é", "Í": "Í", "í": "í", "Ó": "Ó", "ó": "ó", "Ú": "Ú", "ú": "ú", "Ý": "Ý", "ý": "ý"},
	}
	tr1 := func(i int, s string) string {
		if v, t := maps1[i-1][s]; t {
			return v
		}
		return s
	}
	rx2 := regexp2.MustCompile(`([Jj][Oo][Ww]|[Ss][Hh][Cc][Hh]|[CcGgKkSsZzUuOo][Hh]|[Yy][Ww]|[Ee][Hh][Ww]|[Jj][EeIiUuAa]|[Hh][Jj]|[A-GIK-PR-VYZa-gik-pr-vyz])|(?<=[Ss][Hh][Cc][Hh])([Jj]\u0027(?=[AaEeIiUu])|[Jj])|(?<=[CcGgKkSsZz][Hh])([Jj]\u0027(?=[AaEeIiUu])|[Jj])|(?<=[BCDFGKLMNPRSTVZbcdfgklmnprstvzv])([Jj]\u0027(?=[AaEeIiUu])|[Jj])|(\u0027[Jj](?![AaEeIiUu])|\u0027(?=[Jj])|[Jj])`, regexp2.Compiled|regexp2.Unicode)
	maps2 := [...]map[string]string{
		{"A": "А", "a": "а", "B": "Б", "b": "б", "V": "В", "v": "в", "GH": "Г", "Gh": "Г", "gH": "г", "gh": "г", "G": "Ґ", "g": "ґ", "D": "Д", "d": "д", "E": "Е", "e": "е", "JE": "Є", "Je": "Є", "jE": "є", "je": "є", "ZH": "Ж", "Zh": "Ж", "zH": "ж", "zh": "ж", "Z": "З", "z": "з", "Y": "И", "y": "и", "I": "І", "i": "і", "JI": "Ї", "Ji": "Ї", "jI": "ї", "ji": "ї", "KH": "Х", "Kh": "Х", "kH": "х", "kh": "х", "K": "К", "k": "к", "L": "Л", "l": "л", "M": "М", "m": "м", "N": "Н", "n": "н", "O": "О", "o": "о", "P": "П", "p": "п", "R": "Р", "r": "р", "SHCH": "Щ", "SHCh": "Щ", "SHcH": "Щ", "SHch": "Щ", "ShCH": "Щ", "ShCh": "Щ", "ShcH": "Щ", "Shch": "Щ", "sHCH": "щ", "sHCh": "щ", "sHcH": "щ", "sHch": "щ", "shCH": "щ", "shCh": "щ", "shcH": "щ", "shch": "щ", "SH": "Ш", "Sh": "Ш", "sH": "ш", "sh": "ш", "S": "С", "s": "с", "T": "Т", "t": "т", "U": "У", "u": "у", "F": "Ф", "f": "ф", "CH": "Ч", "Ch": "Ч", "cH": "ч", "ch": "ч", "C": "Ц", "c": "ц", "JU": "Ю", "Ju": "Ю", "jU": "ю", "ju": "ю", "JA": "Я", "Ja": "Я", "jA": "я", "ja": "я", "HJ": "Ь", "Hj": "Ь", "hJ": "ь", "hj": "ь", "JOW": "Ё", "JOw": "Ё", "JoW": "Ё", "Jow": "Ё", "jOW": "ё", "jOw": "ё", "joW": "ё", "jow": "ё", "UH": "Ў", "Uh": "Ў", "uH": "ў", "uh": "ў", "OH": "Ъ", "Oh": "Ъ", "oH": "ъ", "oh": "ъ", "YW": "Ы", "Yw": "Ы", "yW": "ы", "yw": "ы", "EHW": "Э", "EHw": "Э", "EhW": "Э", "Ehw": "Э", "eHW": "э", "eHw": "э", "ehW": "э", "ehw": "э"},
		{"J": "Ь", "j": "ь", "J'": "Ь", "j'": "ь"},
		{"J": "Ь", "j": "ь", "J'": "Ь", "j'": "ь"},
		{"J": "Ь", "j": "ь", "J'": "Ь", "j'": "ь"},
		{"'J": "Й", "'j": "й", "'": "’", "J": "Й", "j": "й"},
	}
	tr2 := func(i int, s string) string {
		if v, t := maps2[i-1][s]; t {
			return v
		}
		return s
	}

	return func(text string) string {
		text = norm.NFC.String(text)
		text = replaceAllStringSubmatchFunc(rx1, text, tr1)
		text = replaceAllStringSubmatchFunc(rx2, text, tr2)
		text = norm.NFC.String(text)
		return text
	}
}()

var tables = [...][2]func(string) string{
	{nil, nil},
	{table_uk_uk_Latn_DSTU_9112_A, table_uk_Latn_DSTU_9112_A_uk},
	{table_uk_uk_Latn_DSTU_9112_B, table_uk_Latn_DSTU_9112_B_uk},
	{table_uk_uk_Latn_KMU_55, nil},
}
